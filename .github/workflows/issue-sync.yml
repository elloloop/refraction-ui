name: Issue Sync
on:
  issues:
    types: [opened, edited, closed, reopened, labeled, unlabeled]
  push:
    paths:
      - "issues/issues/**/*.md"
    branches: [main]

jobs:
  github-to-markdown:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && !contains(github.event.issue.labels.*.name, 'synced-from-markdown')
    permissions:
      contents: write
      issues: write
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
      - name: Install dependencies
        run: npm install yaml js-yaml
      - name: Sync GitHub issue to markdown
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const yaml = require('js-yaml');

            const issue = context.payload.issue;
            const action = context.payload.action;

            // Skip if this is a sync from markdown
            if (issue.labels.some(label => label.name === 'synced-from-markdown')) {
              console.log('Skipping - issue was synced from markdown');
              return;
            }

            // Generate issue ID from title or use existing
            const generateIssueId = (title) => {
              return title
                .toUpperCase()
                .replace(/[^A-Z0-9]/g, '-')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '')
                .substring(0, 20);
            };

            const issueId = generateIssueId(issue.title);
            const filename = `${issueId}.md`;
            const filepath = path.join('issues', 'issues', filename);

            // Parse existing content if file exists
            let existingContent = '';
            let existingFrontmatter = {};

            if (fs.existsSync(filepath)) {
              const content = fs.readFileSync(filepath, 'utf8');
              const parts = content.split('---');
              if (parts.length >= 3) {
                existingFrontmatter = yaml.load(parts[1]) || {};
                existingContent = parts.slice(2).join('---').trim();
              }
            }

            // Determine track from labels or existing frontmatter
            const trackLabels = issue.labels
              .filter(label => label.name.startsWith('track/'))
              .map(label => label.name.replace('track/', ''));

            const track = trackLabels[0] || existingFrontmatter.track || 'general';

            // Determine size from labels or existing frontmatter
            const sizeLabels = issue.labels
              .filter(label => label.name.startsWith('size/'))
              .map(label => label.name.replace('size/', ''));

            const size = sizeLabels[0] || existingFrontmatter.size || 'M';

            // Determine type labels
            const typeLabels = issue.labels
              .filter(label => label.name.startsWith('type/'))
              .map(label => label.name.replace('type/', ''));

            const otherLabels = issue.labels
              .filter(label => !label.name.startsWith('track/') && 
                              !label.name.startsWith('size/') && 
                              !label.name.startsWith('type/') &&
                              label.name !== 'synced-from-markdown')
              .map(label => label.name);

            const allLabels = [...typeLabels, ...otherLabels];

            // Create frontmatter
            const frontmatter = {
              id: issueId,
              track: track,
              depends_on: existingFrontmatter.depends_on || [],
              size: size,
              labels: allLabels,
              github_issue: issue.number,
              synced_at: new Date().toISOString()
            };

            // Create markdown content
            const acceptanceCriteria = issue.body 
              ? issue.body.split('\n').map(line => `- ${line}`).join('\n')
              : '- [ ] Define acceptance criteria';

            const frontmatterYaml = yaml.dump(frontmatter);
            const markdownContent = '---\n' + frontmatterYaml + '---\n\n' +
              '## Summary\n' + issue.title + '\n\n' +
              '## Acceptance Criteria\n' + acceptanceCriteria + '\n\n' +
              '## Tasks\n- [ ] Define tasks\n\n' +
              '## Notes\n' +
              'GitHub Issue: #' + issue.number + '\n' +
              'Status: ' + issue.state + '\n' +
              'Created: ' + issue.created_at + '\n' +
              'Updated: ' + issue.updated_at;

            // Write the file
            fs.writeFileSync(filepath, markdownContent);

            // Add synced-from-markdown label to prevent loops
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: ['synced-from-markdown']
            });

            console.log(`Synced GitHub issue #${issue.number} to ${filepath}`);

  markdown-to-github:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && contains(github.event.head_commit.message, 'issues/')
    permissions:
      contents: read
      issues: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
      - name: Install dependencies
        run: npm install yaml js-yaml
      - name: Sync markdown to GitHub issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const yaml = require('js-yaml');

            // Get changed markdown files
            const changedFiles = context.payload.commits
              .flatMap(commit => commit.added.concat(commit.modified))
              .filter(file => file.startsWith('issues/issues/') && file.endsWith('.md'));

            for (const file of changedFiles) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                const parts = content.split('---');
                
                if (parts.length < 3) {
                  console.log(`Skipping ${file} - invalid format`);
                  continue;
                }
                
                const frontmatter = yaml.load(parts[1]);
                const markdownContent = parts.slice(2).join('---').trim();
                
                if (!frontmatter || !frontmatter.id) {
                  console.log(`Skipping ${file} - no ID in frontmatter`);
                  continue;
                }
                
                // Extract information from markdown
                const summaryMatch = markdownContent.match(/## Summary\n(.*?)(?=\n## |$)/s);
                const acceptanceMatch = markdownContent.match(/## Acceptance Criteria\n(.*?)(?=\n## |$)/s);
                const tasksMatch = markdownContent.match(/## Tasks\n(.*?)(?=\n## |$)/s);
                const notesMatch = markdownContent.match(/## Notes\n(.*?)(?=\n## |$)/s);
                
                const title = summaryMatch ? summaryMatch[1].trim() : frontmatter.id;
                const body = [
                  acceptanceMatch ? `## Acceptance Criteria\n${acceptanceMatch[1].trim()}` : '',
                  tasksMatch ? `## Tasks\n${tasksMatch[1].trim()}` : '',
                  notesMatch ? `## Notes\n${notesMatch[1].trim()}` : ''
                ].filter(Boolean).join('\n\n');
                
                // Prepare labels
                const labels = [
                  `track/${frontmatter.track || 'general'}`,
                  `size/${frontmatter.size || 'M'}`,
                  'synced-from-markdown',
                  ...(frontmatter.labels || [])
                ];
                
                // Check if GitHub issue already exists
                if (frontmatter.github_issue) {
                  try {
                    // Update existing issue
                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: frontmatter.github_issue,
                      title: title,
                      body: body,
                      state: frontmatter.status === 'closed' ? 'closed' : 'open'
                    });
                    
                    // Update labels
                    await github.rest.issues.setLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: frontmatter.github_issue,
                      labels: labels
                    });
                    
                    console.log(`Updated GitHub issue #${frontmatter.github_issue} from ${file}`);
                  } catch (error) {
                    console.log(`Failed to update issue #${frontmatter.github_issue}: ${error.message}`);
                  }
                } else {
                  // Create new issue
                  const newIssue = await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: title,
                    body: body,
                    labels: labels
                  });
                  
                                     // Update the markdown file with the GitHub issue number
                   const updatedFrontmatter = {
                     ...frontmatter,
                     github_issue: newIssue.data.number,
                     synced_at: new Date().toISOString()
                   };
                   
                   const updatedFrontmatterYaml = yaml.dump(updatedFrontmatter);
                   const updatedContent = '---\n' + updatedFrontmatterYaml + '---\n\n' + markdownContent;
                   
                   fs.writeFileSync(file, updatedContent);
                   
                   console.log('Created GitHub issue #' + newIssue.data.number + ' from ' + file);
                }
              } catch (error) {
                console.log(`Error processing ${file}: ${error.message}`);
              }
            }
